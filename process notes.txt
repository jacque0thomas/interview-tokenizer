ASSUMPTIONS:
1. "When someone runs the program, get the name of a file."
    This does not specify if the file will be taken from an argument or 
    from the command line over the runtime. In the interest of making this
    user-friendly, the user does not have to provide the file name as as 
    argument. The CLI will ask for it as CLI input. 
2. It is preferential to not make the user install libraries. 
3. "Nice" dictionary output is readable and useful. In pursuit of this,
    this program will give the user the option to output this to a file.
    The
4. In reviewing the specs provided, I'm lea

______

So, the first thing I considered for this exercise is the bird's eye view 
of implementing.

I started abstracting it in my head, then I took a moment.

How about I start in on the command line interface, then create my stubs?

As I started re-acquinting myself with the Python CLI, I remembered that this 
project will definitely be including libraries, so I took a moment to see if 
there were any tokenizing libriaries that would be of help.

From that, I refreshed myself with nltk and tokenizers. nltk would certainly 
have a tokenizer for creating an array, which would be nice. tokenizers could
be useful, but honestly? I could get enough out of just reading the file.

So, I decided to just dive right in and create some of this from scratch. 
It seems to make the most sense, because I wasn't finding anything that would 
be a good enough shortcut to justify forcing someone to install a new library.

_____


In reviewing the specs provided, I'm lead to believe that this was perhaps 
intended to be a program run with only the output specified, and the arugments
to the program should reflect that. In that case, I'll perhaps re-purpose my 
written code as the verbose option. Or maybe I'll scrap it entirely. Undecided.

_____


Hi Tom,

I've wrapped up the coding excercise. Sorry it took so long, I think I was 
definitely overthinking it, thinking about whether you wanted this as an
example of how I can make this user-friendly or how I could make this fit the 
specs closely. I know that in the real world, I would have had the opportunity
to ask you/my customer questions about this program's use case, and what 
knowledge level I could have expected, to make it run the most smoothly for 
the user.

So, without further ado, I'll list my assumptions:
1. As this is a part of evaluating a person's technical knowledge, this program 
    will be read and used by developer professionals or at least people familar
    with python programs. I can trust that they have encountered command line 
    arguments before. I can trust they have read the specs. I can trust that 
    they have Python and likely some common libraries already installed.
2. Although these users would know how, it is preferential to not ask them 
    to install any new libraries, like nltk or tokenizers. More popular
    libraries are probably already installed, but should be noted just in case.
3. Speaking of, the required libraries for this project are: KJSFDNLKDSLKFLSKJDFLKJFLKDSJFLDS
4. The arguments are: LKJSDLKJDSLKDJLSKDJSLKDJSLKDJDSLKJDLKJSDLKSJDLKSDJLSKDJSLD
    If you need help, you can use the -h flag, and argparse will help you.
5. Error catching means that detailed output is preferential. The library argparse
    already comes with some error catching.
